{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/oapp-evm/contracts/oapp/utils/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title RateLimiter\n * @dev Abstract contract for implementing rate limiting functionality. This contract provides a basic framework for\n * rate limiting how often a function can be executed. It is designed to be inherited by other contracts requiring rate\n * limiting capabilities to protect resources or services from excessive use.\n * @dev The ordering of transactions within a given block (timestamp) affects the consumed capacity.\n * @dev Carefully consider the minimum window duration for the given blockchain.  For example, on Ethereum, the minimum\n * window duration should be at least 12 seconds.  If a window less than 12 seconds is configured, then the rate limit\n * will effectively reset with each block, rendering rate limiting ineffective.\n * @dev Carefully consider the proportion of the limit to the window.  If the limit is much smaller than the window, the\n * decay function is lossy.  Consider using a limit that is greater than or equal to the window to avoid this.  This is\n * especially important for blockchains with short average block times.\n *\n * Example 1: Max rate limit reached at beginning of window. As time continues the amount of in flights comes down.\n *\n * Rate Limit Config:\n *   limit: 100 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *\n *      100 | * - (Max limit reached at beginning of window)\n *          |   *\n *          |     *\n *          |       *\n *       50 |         * (After 30 seconds only 50 units in flight)\n *          |           *\n *          |             *\n *          |               *\n *       0  +--|---|---|---|---|-->(After 60 seconds 0 units are in flight)\n *             0  15  30  45  60 (seconds)\n *\n * Example 2: Max rate limit reached at beginning of window. As time continues the amount of in flights comes down\n * allowing for more to be sent. At the 90 second mark, more in flights come in.\n *\n * Rate Limit Config:\n *   limit: 100 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *\n *      100 | * - (Max limit reached at beginning of window)\n *          |   *\n *          |     *\n *          |       *\n *       50 |         *          * (50 inflight)\n *          |           *          *\n *          |             *          *\n *          |               *          *\n *        0  +--|--|--|--|--|--|--|--|--|--> Time\n *              0 15 30 45 60 75 90 105 120  (seconds)\n *\n * Example 3: Max rate limit reached at beginning of window. At the 15 second mark, the window gets updated to 60\n * seconds and the limit gets updated to 50 units. This scenario shows the direct depiction of \"in flight\" from the\n * previous window affecting the current window.\n *\n * Initial Rate Limit Config: For first 15 seconds\n *   limit: 100 units\n *   window: 30 seconds\n *\n * Updated Rate Limit Config: Updated at 15 second mark\n *   limit: 50 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *      100 - *\n *            |*\n *            | *\n *            |  *\n *            |   *\n *            |    *\n *            |     *\n *       75 - |      *\n *            |       *\n *            |        *\n *            |         *\n *            |          *\n *            |           *\n *            |            *\n *            |             *\n *       50 - |              ê´∞ <--(Slope changes at the 15 second mark because of the update.\n *            |               ‚úß *      Window extended to 60 seconds and limit reduced to 50 units.\n *            |                ‚úß Ô∏é   *      Because amountInFlight/lastUpdated do not reset, 50 units are\n *            |                 ‚úß       *      considered in flight from the previous window and the corresponding\n *            |                  ‚úß Ô∏é          *     decay from the previous rate.)\n *            |                   ‚úß              *\n *       25 - |                    ‚úß                 *\n *            |                     ‚úß                    *\n *            |                      ‚úß                        *\n *            |                       ‚úß                           *\n *            |                        ‚úß                              *\n *            |                         ‚úß                                  *\n *            |                          ‚úß                                     *\n *            |                           ‚úß                                        *\n *        0 - +---|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----> Time\n *            0   5    10   15   20   25   30   35   40   45   50   55   60   65   70   75   80   85   90 (seconds)\n *            [  Initial 30 Second Window  ]\n *                          [ --------------- Extended 60 Second Window --------------- ]\n */\nabstract contract RateLimiter {\n\n    /**\n     * @notice Rate Limit struct.\n     * @param amountInFlight The amount in the current window.\n     * @param lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param limit This represents the maximum allowed amount within a given window.\n     * @param window Defines the duration of the rate limiting window.\n     */\n    struct RateLimit {\n        uint256 amountInFlight;\n        uint256 lastUpdated;\n        uint256 limit;\n        uint256 window;\n    }\n\n    /**\n     * @notice Rate Limit Configuration struct.\n     * @param dstEid The destination endpoint id.\n     * @param limit This represents the maximum allowed amount within a given window.\n     * @param window Defines the duration of the rate limiting window.\n     */\n    struct RateLimitConfig {\n        uint32 dstEid;\n        uint256 limit;\n        uint256 window;\n    }\n\n    /**\n     * @dev Mapping from destination endpoint id to RateLimit Configurations.\n     */\n    mapping(uint32 dstEid => RateLimit limit) public rateLimits;\n\n    /**\n     * @notice Emitted when _setRateLimits occurs.\n     * @param rateLimitConfigs An array of `RateLimitConfig` structs representing the rate limit configurations set.\n     * - `dstEid`: The destination endpoint id.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * - `window`: Defines the duration of the rate limiting window.\n     */\n    event RateLimitsChanged(RateLimitConfig[] rateLimitConfigs);\n\n    /**\n     * @notice Error that is thrown when an amount exceeds the rate_limit.\n     */\n    error RateLimitExceeded();\n\n    /**\n     * @notice Get the current amount that can be sent to this destination endpoint id for the given rate limit window.\n     * @param _dstEid The destination endpoint id.\n     * @return currentAmountInFlight The current amount that was sent.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function getAmountCanBeSent(\n        uint32 _dstEid\n    ) external view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        RateLimit memory rl = rateLimits[_dstEid];\n        return _amountCanBeSent(rl.amountInFlight, rl.lastUpdated, rl.limit, rl.window);\n    }\n\n    /**\n     * @notice Sets the Rate Limit.\n     * @param _rateLimitConfigs A `RateLimitConfig` struct representing the rate limit configuration.\n     * - `dstEid`: The destination endpoint id.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * - `window`: Defines the duration of the rate limiting window.\n     */\n    function _setRateLimits(RateLimitConfig[] memory _rateLimitConfigs) internal virtual {\n        unchecked {\n            for (uint256 i = 0; i < _rateLimitConfigs.length; i++) {\n                RateLimit storage rl = rateLimits[_rateLimitConfigs[i].dstEid];\n\n                // @dev Ensure we checkpoint the existing rate limit as to not retroactively apply the new decay rate.\n                _outflow(_rateLimitConfigs[i].dstEid, 0);\n\n                // @dev Does NOT reset the amountInFlight/lastUpdated of an existing rate limit.\n                rl.limit = _rateLimitConfigs[i].limit;\n                rl.window = _rateLimitConfigs[i].window;\n            }\n        }\n        emit RateLimitsChanged(_rateLimitConfigs);\n    }\n\n    /**\n     * @notice Checks current amount in flight and amount that can be sent for a given rate limit window.\n     * @param _amountInFlight The amount in the current window.\n     * @param _lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param _limit This represents the maximum allowed amount within a given window.\n     * @param _window Defines the duration of the rate limiting window.\n     * @return currentAmountInFlight The amount in the current window.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function _amountCanBeSent(\n        uint256 _amountInFlight,\n        uint256 _lastUpdated,\n        uint256 _limit,\n        uint256 _window\n    ) internal view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        uint256 timeSinceLastDeposit = block.timestamp - _lastUpdated;\n        // @dev Presumes linear decay.\n        uint256 decay = (_limit * timeSinceLastDeposit) / (_window > 0 ? _window : 1); // prevent division by zero\n        currentAmountInFlight = _amountInFlight <= decay ? 0 : _amountInFlight - decay;\n        // @dev In the event the _limit is lowered, and the 'in-flight' amount is higher than the _limit, set to 0.\n        amountCanBeSent = _limit <= currentAmountInFlight ? 0 : _limit - currentAmountInFlight;\n    }\n\n    /**\n     * @notice Verifies whether the specified amount falls within the rate limit constraints for the targeted\n     * endpoint ID. On successful verification, it updates amountInFlight and lastUpdated. If the amount exceeds\n     * the rate limit, the operation reverts.\n     * @param _dstEid The destination endpoint id.\n     * @param _amount The amount to check for rate limit constraints.\n     */\n    function _outflow(uint32 _dstEid, uint256 _amount) internal virtual {\n        // @dev By default dstEid that have not been explicitly set will return amountCanBeSent == 0.\n        RateLimit storage rl = rateLimits[_dstEid];\n\n        (uint256 currentAmountInFlight, uint256 amountCanBeSent) = _amountCanBeSent(\n            rl.amountInFlight,\n            rl.lastUpdated,\n            rl.limit,\n            rl.window\n        );\n        if (_amount > amountCanBeSent) revert RateLimitExceeded();\n\n        // @dev Update the storage to contain the new amount and current timestamp.\n        rl.amountInFlight = currentAmountInFlight + _amount;\n        rl.lastUpdated = block.timestamp;\n    }\n\n    /**\n     * @notice To be used when you want to calculate your rate limits as a function of net outbound AND inbound.\n     * ie. If you move 150 out, and 100 in, you effective inflight should be 50.\n     * Does not need to update decay values, as the inflow is effective immediately.\n     * @param _srcEid The source endpoint id.\n     * @param _amount The amount to inflow back and deduct from amountInFlight.\n     */\n    function _inflow(uint32 _srcEid, uint256 _amount) internal virtual {\n        RateLimit storage rl = rateLimits[_srcEid];\n        rl.amountInFlight = _amount >= rl.amountInFlight ? 0 : rl.amountInFlight - _amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/IOverridableInboundRateLimiter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\nimport { RateLimiter } from \"@layerzerolabs/oapp-evm/contracts/oapp/utils/RateLimiter.sol\";\n\nstruct RateLimitExemptAddress {\n    address addr;\n    bool isExempt;\n}\n\ninterface IOverridableInboundRateLimiter {\n    error InputLengthMismatch(uint256 addressOrGUIDLength, uint256 overridableLength); // 0x6b7f6f0e\n\n    event RateLimitUpdated(RateLimiter.RateLimitConfig[] newConfigs);\n    event RateLimitOverrider_ModifiedAddress(RateLimitExemptAddress[] indexed addresses);\n    event RateLimitOverrider_ModifiedGUID(bytes32[] indexed guid, bool canOverride);\n\n    /// ------------------------------------------------------------------------------\n    /// Storage Variables\n    /// ------------------------------------------------------------------------------\n    function exemptAddresses(address addr) external view returns (bool isExempt);\n    function guidOverrides(bytes32 guid) external view returns (bool canOverride);\n\n    /*\n     * @notice Sets the rate limits for the contract.\n     * @param _rateLimitConfigs The rate limit configurations to set.\n     * @dev This function can only be called by the owner of the contract.\n     * @dev Emits a RateLimitUpdated event.\n     */\n    function setRateLimits(RateLimiter.RateLimitConfig[] calldata rateLimitConfigs) external;\n\n    /*\n     * @notice Modifies the rate limit exempt addresses in bulk.\n     * @dev This function allows the owner to set multiple addresses as exempt or not exempt.\n     * @param _exemptAddresses The addresses to modify as an object of (address, isExempt).\n     */\n    function modifyRateLimitExemptAddresses(RateLimitExemptAddress[] calldata _exemptAddresses) external;\n\n    /*\n     * @notice Modifies the overridable GUIDs in bulk.\n     * @dev This function allows the owner to set multiple GUIDs as overridable or not overridable.\n     * @param guids The GUIDs to modify.\n     * @param canOverride The boolean values indicating whether each GUID is overridable (or not) from the rate limit.\n     * @dev canOverride is applied to all GUIDs in the array.\n     */\n    function modifyOverridableGUIDs(bytes32[] calldata guids, bool canOverride) external;\n}\n"
    },
    "contracts/OverridableInboundRateLimiter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { RateLimiter } from \"@layerzerolabs/oapp-evm/contracts/oapp/utils/RateLimiter.sol\";\n\nimport { IOverridableInboundRateLimiter, RateLimitExemptAddress } from \"./interfaces/IOverridableInboundRateLimiter.sol\";\n\n/**\n * @title OverridableRateLimiter\n * @author LayerZero Labs (@shankars99)\n * @dev Abstract contract that provides overridable inbound rate limiting functionality for OFT contracts.\n * @dev This contract can be inherited by any LayerZero OFT adapter (MintBurnOFTAdapter, OFTAdapter, NativeOFTAdapter, etc.)\n * @dev to add rate limiting with exemption and override capabilities.\n */\nabstract contract OverridableInboundRateLimiter is RateLimiter, Ownable, IOverridableInboundRateLimiter {\n    /// @dev Mapping to track addresses exempt from rate limiting\n    mapping(address => bool) public exemptAddresses;\n\n    /// @dev Mapping to track GUIDs that can override rate limiting\n    mapping(bytes32 => bool) public guidOverrides;\n\n    /**\n     * @notice Sets the rate limits for the contract.\n     * @param _rateLimitConfigs The rate limit configurations to set.\n     * @dev This function can only be called by the owner of the contract.\n     * @dev Emits a RateLimitUpdated event.\n     */\n    function setRateLimits(RateLimitConfig[] calldata _rateLimitConfigs) external onlyOwner {\n        _setRateLimits(_rateLimitConfigs);\n        emit RateLimitUpdated(_rateLimitConfigs);\n    }\n\n    /**\n     * @notice Modifies the rate limit exempt addresses in bulk.\n     * @dev This function allows the owner to set multiple addresses as exempt or not exempt.\n     * @param _exemptAddresses The addresses to modify as an object of (address, isExempt).\n     */\n    function modifyRateLimitExemptAddresses(RateLimitExemptAddress[] calldata _exemptAddresses) external onlyOwner {\n        for (uint256 i; i < _exemptAddresses.length; ++i) {\n            exemptAddresses[_exemptAddresses[i].addr] = _exemptAddresses[i].isExempt;\n        }\n\n        emit RateLimitOverrider_ModifiedAddress(_exemptAddresses);\n    }\n\n    /**\n     * @notice Modifies the overridable GUIDs in bulk.\n     * @dev This function allows the owner to set multiple GUIDs as overridable or not overridable.\n     * @dev This is used when a message with a normal recipient has failed due to rate limiting.\n     *      This allows the owner to override the rate limit for that GUID and that tx can be re-executed at the endpoint.\n     * @param _guids The GUIDs to modify.\n     * @dev `_canOverride` is applied to all GUIDs in the array.\n     */\n    function modifyOverridableGUIDs(bytes32[] calldata _guids, bool _canOverride) external onlyOwner {\n        for (uint256 i; i < _guids.length; ++i) {\n            guidOverrides[_guids[i]] = _canOverride;\n        }\n        emit RateLimitOverrider_ModifiedGUID(_guids, _canOverride);\n    }\n\n    /**\n     * @notice Apply rate limiting for outbound transfers (inverted to act as inbound rate limit)\n     * @dev Uses LayerZero's outbound rate limiter in reverse - calling _inflow() to consume capacity\n     * @param _from The address from which the debit is made.\n     * @param _amountLD The amount to debit in local denomination.\n     * @param _dstEid The destination endpoint ID.\n     */\n    function _outflowOverridable(address _from, uint256 _amountLD, uint32 _dstEid) internal virtual {\n        /// @dev Apply outbound rate limiting if sender is not exempt\n        if (!exemptAddresses[_from]) {\n            /// @dev The original LayerZero rate limiter is an outbound rate limit.\n            /// @dev A unidirectional graph can be inverted by swapping the inflow and outflow functions.\n            /// @dev This makes the rate limiter an inbound rate limit.\n            super._inflow(_dstEid, _amountLD);\n        }\n    }\n\n    /**\n     * @notice Apply rate limiting for inbound transfers (inverted to act as inbound rate limit)\n     * @dev Uses LayerZero's outbound rate limiter in reverse - calling _outflow() to consume capacity\n     * @param _guid The GUID of the message.\n     * @param _to The address of the recipient.\n     * @param _amountLD The amount of tokens received in local decimals.\n     * @param _srcEid The source chain ID.\n     */\n    function _inflowOverridable(bytes32 _guid, address _to, uint256 _amountLD, uint32 _srcEid) internal virtual {\n        /// @dev Apply inbound rate limiting if recipient is not exempt and GUID is not overridable\n        if (!exemptAddresses[_to] && !guidOverrides[_guid]) {\n            /// @dev The original LayerZero rate limiter is an outbound rate limit.\n            /// @dev Switching `inflow` and `outflow` makes the rate limiter an inbound rate limit.\n            super._outflow(_srcEid, _amountLD);\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}