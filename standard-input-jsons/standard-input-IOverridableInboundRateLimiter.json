{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/oapp-evm/contracts/oapp/utils/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title RateLimiter\n * @dev Abstract contract for implementing rate limiting functionality. This contract provides a basic framework for\n * rate limiting how often a function can be executed. It is designed to be inherited by other contracts requiring rate\n * limiting capabilities to protect resources or services from excessive use.\n * @dev The ordering of transactions within a given block (timestamp) affects the consumed capacity.\n * @dev Carefully consider the minimum window duration for the given blockchain.  For example, on Ethereum, the minimum\n * window duration should be at least 12 seconds.  If a window less than 12 seconds is configured, then the rate limit\n * will effectively reset with each block, rendering rate limiting ineffective.\n * @dev Carefully consider the proportion of the limit to the window.  If the limit is much smaller than the window, the\n * decay function is lossy.  Consider using a limit that is greater than or equal to the window to avoid this.  This is\n * especially important for blockchains with short average block times.\n *\n * Example 1: Max rate limit reached at beginning of window. As time continues the amount of in flights comes down.\n *\n * Rate Limit Config:\n *   limit: 100 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *\n *      100 | * - (Max limit reached at beginning of window)\n *          |   *\n *          |     *\n *          |       *\n *       50 |         * (After 30 seconds only 50 units in flight)\n *          |           *\n *          |             *\n *          |               *\n *       0  +--|---|---|---|---|-->(After 60 seconds 0 units are in flight)\n *             0  15  30  45  60 (seconds)\n *\n * Example 2: Max rate limit reached at beginning of window. As time continues the amount of in flights comes down\n * allowing for more to be sent. At the 90 second mark, more in flights come in.\n *\n * Rate Limit Config:\n *   limit: 100 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *\n *      100 | * - (Max limit reached at beginning of window)\n *          |   *\n *          |     *\n *          |       *\n *       50 |         *          * (50 inflight)\n *          |           *          *\n *          |             *          *\n *          |               *          *\n *        0  +--|--|--|--|--|--|--|--|--|--> Time\n *              0 15 30 45 60 75 90 105 120  (seconds)\n *\n * Example 3: Max rate limit reached at beginning of window. At the 15 second mark, the window gets updated to 60\n * seconds and the limit gets updated to 50 units. This scenario shows the direct depiction of \"in flight\" from the\n * previous window affecting the current window.\n *\n * Initial Rate Limit Config: For first 15 seconds\n *   limit: 100 units\n *   window: 30 seconds\n *\n * Updated Rate Limit Config: Updated at 15 second mark\n *   limit: 50 units\n *   window: 60 seconds\n *\n *                              Amount in Flight (units) vs. Time Graph (seconds)\n *      100 - *\n *            |*\n *            | *\n *            |  *\n *            |   *\n *            |    *\n *            |     *\n *       75 - |      *\n *            |       *\n *            |        *\n *            |         *\n *            |          *\n *            |           *\n *            |            *\n *            |             *\n *       50 - |              ê´∞ <--(Slope changes at the 15 second mark because of the update.\n *            |               ‚úß *      Window extended to 60 seconds and limit reduced to 50 units.\n *            |                ‚úß Ô∏é   *      Because amountInFlight/lastUpdated do not reset, 50 units are\n *            |                 ‚úß       *      considered in flight from the previous window and the corresponding\n *            |                  ‚úß Ô∏é          *     decay from the previous rate.)\n *            |                   ‚úß              *\n *       25 - |                    ‚úß                 *\n *            |                     ‚úß                    *\n *            |                      ‚úß                        *\n *            |                       ‚úß                           *\n *            |                        ‚úß                              *\n *            |                         ‚úß                                  *\n *            |                          ‚úß                                     *\n *            |                           ‚úß                                        *\n *        0 - +---|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----|----> Time\n *            0   5    10   15   20   25   30   35   40   45   50   55   60   65   70   75   80   85   90 (seconds)\n *            [  Initial 30 Second Window  ]\n *                          [ --------------- Extended 60 Second Window --------------- ]\n */\nabstract contract RateLimiter {\n\n    /**\n     * @notice Rate Limit struct.\n     * @param amountInFlight The amount in the current window.\n     * @param lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param limit This represents the maximum allowed amount within a given window.\n     * @param window Defines the duration of the rate limiting window.\n     */\n    struct RateLimit {\n        uint256 amountInFlight;\n        uint256 lastUpdated;\n        uint256 limit;\n        uint256 window;\n    }\n\n    /**\n     * @notice Rate Limit Configuration struct.\n     * @param dstEid The destination endpoint id.\n     * @param limit This represents the maximum allowed amount within a given window.\n     * @param window Defines the duration of the rate limiting window.\n     */\n    struct RateLimitConfig {\n        uint32 dstEid;\n        uint256 limit;\n        uint256 window;\n    }\n\n    /**\n     * @dev Mapping from destination endpoint id to RateLimit Configurations.\n     */\n    mapping(uint32 dstEid => RateLimit limit) public rateLimits;\n\n    /**\n     * @notice Emitted when _setRateLimits occurs.\n     * @param rateLimitConfigs An array of `RateLimitConfig` structs representing the rate limit configurations set.\n     * - `dstEid`: The destination endpoint id.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * - `window`: Defines the duration of the rate limiting window.\n     */\n    event RateLimitsChanged(RateLimitConfig[] rateLimitConfigs);\n\n    /**\n     * @notice Error that is thrown when an amount exceeds the rate_limit.\n     */\n    error RateLimitExceeded();\n\n    /**\n     * @notice Get the current amount that can be sent to this destination endpoint id for the given rate limit window.\n     * @param _dstEid The destination endpoint id.\n     * @return currentAmountInFlight The current amount that was sent.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function getAmountCanBeSent(\n        uint32 _dstEid\n    ) external view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        RateLimit memory rl = rateLimits[_dstEid];\n        return _amountCanBeSent(rl.amountInFlight, rl.lastUpdated, rl.limit, rl.window);\n    }\n\n    /**\n     * @notice Sets the Rate Limit.\n     * @param _rateLimitConfigs A `RateLimitConfig` struct representing the rate limit configuration.\n     * - `dstEid`: The destination endpoint id.\n     * - `limit`: This represents the maximum allowed amount within a given window.\n     * - `window`: Defines the duration of the rate limiting window.\n     */\n    function _setRateLimits(RateLimitConfig[] memory _rateLimitConfigs) internal virtual {\n        unchecked {\n            for (uint256 i = 0; i < _rateLimitConfigs.length; i++) {\n                RateLimit storage rl = rateLimits[_rateLimitConfigs[i].dstEid];\n\n                // @dev Ensure we checkpoint the existing rate limit as to not retroactively apply the new decay rate.\n                _outflow(_rateLimitConfigs[i].dstEid, 0);\n\n                // @dev Does NOT reset the amountInFlight/lastUpdated of an existing rate limit.\n                rl.limit = _rateLimitConfigs[i].limit;\n                rl.window = _rateLimitConfigs[i].window;\n            }\n        }\n        emit RateLimitsChanged(_rateLimitConfigs);\n    }\n\n    /**\n     * @notice Checks current amount in flight and amount that can be sent for a given rate limit window.\n     * @param _amountInFlight The amount in the current window.\n     * @param _lastUpdated Timestamp representing the last time the rate limit was checked or updated.\n     * @param _limit This represents the maximum allowed amount within a given window.\n     * @param _window Defines the duration of the rate limiting window.\n     * @return currentAmountInFlight The amount in the current window.\n     * @return amountCanBeSent The amount that can be sent.\n     */\n    function _amountCanBeSent(\n        uint256 _amountInFlight,\n        uint256 _lastUpdated,\n        uint256 _limit,\n        uint256 _window\n    ) internal view virtual returns (uint256 currentAmountInFlight, uint256 amountCanBeSent) {\n        uint256 timeSinceLastDeposit = block.timestamp - _lastUpdated;\n        // @dev Presumes linear decay.\n        uint256 decay = (_limit * timeSinceLastDeposit) / (_window > 0 ? _window : 1); // prevent division by zero\n        currentAmountInFlight = _amountInFlight <= decay ? 0 : _amountInFlight - decay;\n        // @dev In the event the _limit is lowered, and the 'in-flight' amount is higher than the _limit, set to 0.\n        amountCanBeSent = _limit <= currentAmountInFlight ? 0 : _limit - currentAmountInFlight;\n    }\n\n    /**\n     * @notice Verifies whether the specified amount falls within the rate limit constraints for the targeted\n     * endpoint ID. On successful verification, it updates amountInFlight and lastUpdated. If the amount exceeds\n     * the rate limit, the operation reverts.\n     * @param _dstEid The destination endpoint id.\n     * @param _amount The amount to check for rate limit constraints.\n     */\n    function _outflow(uint32 _dstEid, uint256 _amount) internal virtual {\n        // @dev By default dstEid that have not been explicitly set will return amountCanBeSent == 0.\n        RateLimit storage rl = rateLimits[_dstEid];\n\n        (uint256 currentAmountInFlight, uint256 amountCanBeSent) = _amountCanBeSent(\n            rl.amountInFlight,\n            rl.lastUpdated,\n            rl.limit,\n            rl.window\n        );\n        if (_amount > amountCanBeSent) revert RateLimitExceeded();\n\n        // @dev Update the storage to contain the new amount and current timestamp.\n        rl.amountInFlight = currentAmountInFlight + _amount;\n        rl.lastUpdated = block.timestamp;\n    }\n\n    /**\n     * @notice To be used when you want to calculate your rate limits as a function of net outbound AND inbound.\n     * ie. If you move 150 out, and 100 in, you effective inflight should be 50.\n     * Does not need to update decay values, as the inflow is effective immediately.\n     * @param _srcEid The source endpoint id.\n     * @param _amount The amount to inflow back and deduct from amountInFlight.\n     */\n    function _inflow(uint32 _srcEid, uint256 _amount) internal virtual {\n        RateLimit storage rl = rateLimits[_srcEid];\n        rl.amountInFlight = _amount >= rl.amountInFlight ? 0 : rl.amountInFlight - _amount;\n    }\n}\n"
    },
    "contracts/interfaces/IOverridableInboundRateLimiter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.22;\nimport { RateLimiter } from \"@layerzerolabs/oapp-evm/contracts/oapp/utils/RateLimiter.sol\";\n\nstruct RateLimitExemptAddress {\n    address addr;\n    bool isExempt;\n}\n\ninterface IOverridableInboundRateLimiter {\n    error InputLengthMismatch(uint256 addressOrGUIDLength, uint256 overridableLength); // 0x6b7f6f0e\n\n    event RateLimitUpdated(RateLimiter.RateLimitConfig[] newConfigs);\n    event RateLimitOverrider_ModifiedAddress(RateLimitExemptAddress[] indexed addresses);\n    event RateLimitOverrider_ModifiedGUID(bytes32[] indexed guid, bool canOverride);\n\n    /// ------------------------------------------------------------------------------\n    /// Storage Variables\n    /// ------------------------------------------------------------------------------\n    function exemptAddresses(address addr) external view returns (bool isExempt);\n    function guidOverrides(bytes32 guid) external view returns (bool canOverride);\n\n    /*\n     * @notice Sets the rate limits for the contract.\n     * @param _rateLimitConfigs The rate limit configurations to set.\n     * @dev This function can only be called by the owner of the contract.\n     * @dev Emits a RateLimitUpdated event.\n     */\n    function setRateLimits(RateLimiter.RateLimitConfig[] calldata rateLimitConfigs) external;\n\n    /*\n     * @notice Modifies the rate limit exempt addresses in bulk.\n     * @dev This function allows the owner to set multiple addresses as exempt or not exempt.\n     * @param _exemptAddresses The addresses to modify as an object of (address, isExempt).\n     */\n    function modifyRateLimitExemptAddresses(RateLimitExemptAddress[] calldata _exemptAddresses) external;\n\n    /*\n     * @notice Modifies the overridable GUIDs in bulk.\n     * @dev This function allows the owner to set multiple GUIDs as overridable or not overridable.\n     * @param guids The GUIDs to modify.\n     * @param canOverride The boolean values indicating whether each GUID is overridable (or not) from the rate limit.\n     * @dev canOverride is applied to all GUIDs in the array.\n     */\n    function modifyOverridableGUIDs(bytes32[] calldata guids, bool canOverride) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}